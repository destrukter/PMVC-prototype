#include "calculation.hpp"

/*
// This method was generated by ChatGpt
Eigen::VectorXd computePMVC(
    const Eigen::MatrixXd &V,   // cage vertices (Nx3)
    const Eigen::MatrixXi &F,   // cage faces (Mx3)
    const Eigen::RowVector3d &p // query point (1x3)
)
{
    Eigen::VectorXd weights = Eigen::VectorXd::Zero(V.rows());

    Eigen::MatrixXd FN; // face normals
    igl::per_face_normals(V, F, FN);

    for (int i = 0; i < F.rows(); ++i)
    {
        // Get triangle vertices
        Eigen::RowVector3d v0 = V.row(F(i, 0));
        Eigen::RowVector3d v1 = V.row(F(i, 1));
        Eigen::RowVector3d v2 = V.row(F(i, 2));

        Eigen::RowVector3d r0 = v0 - p;
        Eigen::RowVector3d r1 = v1 - p;
        Eigen::RowVector3d r2 = v2 - p;

        double r0_len = r0.norm();
        double r1_len = r1.norm();
        double r2_len = r2.norm();

        double triple = r0.dot(r1.cross(r2));

        double denom =
            r0_len * r1_len * r2_len +
            r0.dot(r1) * r2_len +
            r1.dot(r2) * r0_len +
            r2.dot(r0) * r1_len;

        double omega = 2.0 * atan2(triple, denom);

        // Ensure positive contribution
        omega = std::abs(omega);

        // Compute area of triangle (or reuse FN)
        double area = 0.5 * (v1 - v0).cross(v2 - v0).norm();

        double w0 = omega / (r0_len * area);
        double w1 = omega / (r1_len * area);
        double w2 = omega / (r2_len * area);

        // Accumulate
        weights(F(i, 0)) += w0;
        weights(F(i, 1)) += w1;
        weights(F(i, 2)) += w2;
    }

    // Normalize
    double sum = weights.sum();
    if (sum > 0)
    {
        weights /= sum;
    }

    return weights;
}
*/

/*
// This method was generated by ChatGpt
Eigen::MatrixXd computePMVCForMesh(
    const Eigen::MatrixXd &Vmesh,
    const Eigen::MatrixXd &Vcage,
    const Eigen::MatrixXi &Fcage)
{
    Eigen::MatrixXd weights(Vmesh.rows(), Vcage.rows());

    for (int i = 0; i < Vmesh.rows(); ++i)
    {
        weights.row(i) = computePMVC(Vcage, Fcage, Vmesh.row(i)).transpose();
    }

    return weights;
}
*/

Eigen::MatrixXd
applyDeformation(
    const Eigen::MatrixXd &weights,
    const Eigen::MatrixXd &VdeformedCage)
{
    return weights.transpose() * VdeformedCage; // Each vertex is a weighted sum of deformed cage vertices
}

bool fileExists(const std::string &path)
{
    std::ifstream file(path);
    return file.good();
}

/// A simple but more robust scheme to compute MVC supposed in https://github.com/superboubek/QMVC
void computeMVCForOneVertexSimple(Eigen::MatrixXd const &C, Eigen::MatrixXi const &CF,
                                  Eigen::Vector3d eta, Eigen::VectorXd &weights, Eigen::VectorXd &w_weights)
{
    double epsilon = 0.000000001;

    auto const num_vertices_cage = C.rows();
    auto const num_faces_cage = CF.rows();

    w_weights.setZero();
    weights.setZero();
    double sumWeights = 0.0;

    Eigen::VectorXd d(num_vertices_cage);
    d.setZero();
    Eigen::MatrixXd u(num_vertices_cage, 3);

    for (unsigned int v = 0; v < num_vertices_cage; ++v)
    {
        const Eigen::Vector3d cage_vertex = C.row(v);
        d(v) = (eta - cage_vertex).norm();
        if (d(v) < epsilon)
        {
            weights(v) = 1.0;
            return;
        }
        u.row(v) = (cage_vertex - eta) / d(v);
    }

    unsigned int vid[3];
    double l[3], theta[3], w[3];

    for (unsigned int t = 0; t < num_faces_cage; ++t)
    {
        // the Norm is CCW :
        for (unsigned int i = 0; i <= 2; ++i)
        {
            vid[i] = CF(t, i);
        }

        for (unsigned int i = 0; i <= 2; ++i)
        {
            const Eigen::Vector3d v_0 = u.row(vid[(i + 1) % 3]);
            const Eigen::Vector3d v_1 = u.row(vid[(i + 2) % 3]);
            l[i] = (v_0 - v_1).norm();
        }

        for (unsigned int i = 0; i <= 2; ++i)
        {
            const Eigen::Vector3d v_0 = u.row(vid[(i + 1) % 3]);
            const Eigen::Vector3d v_1 = u.row(vid[(i + 2) % 3]);
            theta[i] = 2. * asin((v_0 - v_1).norm() * .5);
        }

        // test in original MVC paper: (they test if one angle psi is close to 0: it is "distance sensitive" in the sense that it does not
        // relate directly to the distance to the support plane of the triangle, and the more far away you go from the triangle, the worse it is)
        // In our experiments, it is actually not the good way to do it, as it increases significantly the errors we get in the computation of weights and derivatives,
        // especially when evaluating Hfx, Hfy, Hfz which can be of norm of the order of 10^3 instead of 0 (when specifying identity on the cage, see paper)

        // simple test we suggest:
        // the determinant of the basis is 2*area(T)*d( eta , support(T) ), we can directly test for the distance to support plane of the triangle to be minimum

        const Eigen::Vector3d c_0 = C.row(vid[0]);
        const Eigen::Vector3d c_1 = C.row(vid[1]);
        const Eigen::Vector3d c_2 = C.row(vid[2]);
        double determinant = (c_0 - eta).dot((c_1 - c_0).cross(c_2 - c_0));
        double sqrdist = determinant * determinant / (4 * ((c_1 - c_0).cross(c_2 - c_0)).squaredNorm());
        double dist = std::sqrt(sqrdist);

        if (dist < epsilon)
        {
            // then the point eta lies on the support plane of the triangle
            double h = (theta[0] + theta[1] + theta[2]) * .5;
            if (M_PI - h < epsilon)
            {
                // eta lies inside the triangle t , use 2d barycentric coordinates :
                for (unsigned int i = 0; i <= 2; ++i)
                {
                    w[i] = sin(theta[i]) * l[(i + 2) % 3] * l[(i + 1) % 3];
                }
                sumWeights = w[0] + w[1] + w[2];

                w_weights.setZero();
                weights(vid[0]) = w[0] / sumWeights;
                weights(vid[1]) = w[1] / sumWeights;
                weights(vid[2]) = w[2] / sumWeights;
                return;
            }
        }

        Eigen::Vector3d pt[3], N[3];
        for (unsigned int i = 0; i < 3; ++i)
        {
            pt[i] = C.row(CF(t, i));
        }
        for (unsigned int i = 0; i < 3; ++i)
        {
            N[i] = (pt[(i + 1) % 3] - eta).cross(pt[(i + 2) % 3] - eta);
        }

        for (unsigned int i = 0; i <= 2; ++i)
        {
            w[i] = 0.0;
            for (unsigned int j = 0; j <= 2; ++j)
            {
                w[i] += theta[j] * N[i].dot(N[j]) / (2.0 * N[j].norm());
            }
            w[i] /= determinant;
        }

        sumWeights += (w[0] + w[1] + w[2]);
        w_weights(vid[0]) += w[0];
        w_weights(vid[1]) += w[1];
        w_weights(vid[2]) += w[2];
    }

    for (unsigned int v = 0; v < num_vertices_cage; ++v)
    {
        weights(v) = w_weights(v) / sumWeights;
    }
}

void computeMVC(const Eigen::MatrixXd &C, const Eigen::MatrixXi &CF, Eigen::MatrixXd const &eta_m,
                Eigen::MatrixXd &phi)
{
    phi.resize(C.rows(), eta_m.rows());
    Eigen::VectorXd w_weights(C.rows());
    Eigen::VectorXd weights(C.rows());

    for (int eta_idx = 0; eta_idx < eta_m.rows(); ++eta_idx)
    {
        const Eigen::Vector3d eta = eta_m.row(eta_idx);
        computeMVCForOneVertexSimple(C, CF, eta, weights, w_weights);
        phi.col(eta_idx) = weights;
    }
}

void computePMVCwithMVC()
{
}